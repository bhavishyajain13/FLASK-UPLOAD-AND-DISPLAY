def detect_squares(thresh):
    # Find edges using Canny edge detection
    edges = cv2.Canny(thresh, 50, 150, apertureSize=3)
    
    # Find lines using Hough Transform
    lines = cv2.HoughLines(edges, 1, np.pi / 180, 100)
    
    # Filter lines to find squares
    squares = []
    if lines is not None:
        for line in lines:
            rho, theta = line[0]
            a = np.cos(theta)
            b = np.sin(theta)
            x0 = a * rho
            y0 = b * rho
            x1 = int(x0 + 1000 * (-b))
            y1 = int(y0 + 1000 * (a))
            x2 = int(x0 - 1000 * (-b))
            y2 = int(y0 - 1000 * (a))
            angle = np.abs(np.arctan2(y2 - y1, x2 - x1) * 180 / np.pi)
            if 75 < angle < 105:  # Filter lines to approximate squares
                squares.append((x1, y1, x2, y2))
    
    # Draw squares
    square_image = np.zeros_like(thresh)
    for square in squares:
        cv2.line(square_image, (square[0], square[1]), (square[2], square[3]), (255, 255, 255), 2)
    
    return square_image
