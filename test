
from azure.ai.vision.imageanalysis import ImageAnalysisClient
from azure.core.credentials import AzureKeyCredential
from PIL import Image
from azure.ai.vision.imageanalysis.models import VisualFeatures
from openai import OpenAI
from datetime import date
import sec as sc
import warnings
warnings.filterwarnings('ignore')
import json,fitz,re,os,datetime, requests, dotenv,threading, time
dotenv.load_dotenv()
from pdf2image import convert_from_path
from docx import Document
from docx.shared import Inches

key=sc.key
endpoint= sc.endpoints
openai_key=sc.openai_key
os.environ["HTTP_PROXY"]="http://10.16.36.82:8080"

prompt1="""You are a bot that analyses and understands text from the given unclean data. Data for everything will be present after the keyword. Follow the instructions 
after "-" in every field and extract the fields. If data not found put "NOT FOUND". Give the dates in this format "YYYY-MM-DD" and use The date present after UMRN FIELD.

ALL THR 21 FIELDS HAVE TO PRESENT IN THE OUTPUT.

1) Mandate Type - Can be pan based mandate, folio based mandate or not found. 
2) UMRN - value is present betweem the key word "UMRN" and "Date". ALWAYS 20 CHARACTERS.
3) Application Date -  FIND THE DATE
4) Sponsor Bank Code
5) Utility Code
6) Operation - Is a single choice value. It can either be Create or Modify or Cancel. Whichever option has a "/"  or "V" after it, should be the correct choice
7) Authorisation - is the bank name after "we hereby authorize".
8) Bank Account Type - Bank Account Type is the field "to debit (tick/)" and it's a single choice value. Options for this field "SB" OR "CA" OR "CC" OR "SB-NRE" OR "SB-NRID" OR OTHER. Which ever field has a "/" before it is the correct choice.
9) Bank Account Number 
10) Bank Name - is the value after  "with bank" field.
11) IFSC
12) PAN  - Pan is in the format <5 Letters><4 Numbers><1 Letter>. Somtimes might be in 2 halves next to each other, merge it in that case 
13) MICR
14) Amount of rupees(in words)
15) Amount - A numerical value Usually present after "â‚¹" represent money   
16) Application Number
17) From Date,
18) To Date
19) Name 
20) mobile_no
21) email_id  
Follow These instructions:

ALL OUTPUT JSON FORMAT:  { KEY_1:VALUE_1, KEY_2:VALUE_2, ....  KEY_21 : VALUE_21  }
"""

prompt2="""You are a bot that analyses and understands text from the given unclean data. Data for everything will be present after the keyword. Follow the instructions 
after "-" in every field and extract the fields. If data not found put "NOT FOUND". 

1) Folio No - Always present between "Folio No" and "DATE OF BIRTH" else put "NOT FOUND"
2) Date_of_birth - GIVE IN YYYY-MM-DD FORMAT
3) Scheme_name  - 
4) From Date - WILL BE PRESENT IN MM-YYY FORMAT
5) To Date - WILL BE PRESENT IN MM-YYY FORMAT
6) Applicant Name - 
7) SIP Amount - Present mostly after scheme name and befre from date
8) Frequency 
9) Registration via otm - If Registration via otm has a "/" or "V" before it mark it True else  STRICTLY False
10) Investor Name - Cannot be similar or same as scheme name
11) Cycle Date -  always 2 digit. It is the montly cycle date.

ALL OUTPUT JSON FORMAT:  { KEY_1:VALUE_1, KEY_2:VALUE_2  }
"""

client = ImageAnalysisClient(
    endpoint=endpoint,
    credential=AzureKeyCredential(key),
)

with open("IFSC_BANK_JSON/banknames.json") as f:
    bank_nm_db = json.load(f)

with open("IFSC_BANK_JSON/IFSC.json") as f:
    ifsc_db = json.load(f)

def get_ans(image_url):
    with open(image_url, "rb") as f:
        image_data = f.read()
    
    visual_features =[
        VisualFeatures.READ,
    ]

    result = client.analyze(
        image_data=image_data,
        visual_features=visual_features,
        smart_crops_aspect_ratios=[0.9, 1.33],
        gender_neutral_caption=True,
        language="en"
    )
    
    data = result["readResult"]["blocks"][0]["lines"]
    image_text_content=""
    for dt in data:
        # print(dt["text"])
        image_text_content+=dt["text"]+"\n"
        
    return image_text_content.replace("UMAN","UMRN")


def gpt_format(aztext,prompt_temp): 

    prompt=prompt_temp


    messages = [
        {"role": "system", "content": prompt},
        {"role": "user", "content": aztext},
    ]
    chat = requests.post(
        url=os.environ["OpenBaseUrl"]
        + "/openai/deployments/poc/chat/completions?api-version=2023-07-01-preview",
        headers={"api-key":os.environ["OpenAIKey"]},
        json={
            "model": "poc",
            "messages": messages,
            "response_format": {"type": "json_object"},
            "temperature": 0,
            "max_tokens": None,
            "stop": None,
        },
        verify=False,
    )
    if chat.status_code != 200:
        print(chat.json())
    
    return json.loads( chat.json()["choices"][0]["message"]["content"] )



def vali_umrn(gpt_json):
    if gpt_json["UMRN"]=="NOT FOUND":
        return"UMRN - VALID"
    else:
        gpt_json["UMRN"] =  gpt_json["UMRN"].replace(" ","")

        temp_str="FOROFFICEUSEONLY"

        if len( gpt_json["UMRN"] ) <= 16:
            for i in range(len(temp_str)):
                if temp_str[i:] in gpt_json["UMRN"]:
                    # print(i,temp_str[i:])
                    gpt_json["UMRN"]= gpt_json["UMRN"].replace(temp_str[i:],"")
                    break

            if gpt_json["UMRN"] == "":
                # print(gpt_json["UMRN"])
                gpt_json["UMRN"] = "NOT FOUND"
                return "UMRN - VALID"
            else:
                if len(gpt_json["UMRN"]) <=16 :
                    gpt_json["UMRN"] = "NOT FOUND"

                return "UMRN - INVALID (BECAUSE UMRN FIELD IS NOT EMPTY)"
                
        else:
            if len( gpt_json["UMRN"] ) == 20:   
                umrn_regex = re.compile(r'[A-Z]{4}[0-9]{16}')
                mo = umrn_regex.search(gpt_json["UMRN"])
                if mo == None:
                    return "UMRN - INVALID (BECAUSE UMRN FORMAT IS WRONG)"
                else:
                    return "UMRN - VALID"
            else:
                return "UMRN - VALID"

def vali_sbc(gpt_json):
    if gpt_json["Sponsor Bank Code"]=="NOT FOUND":
        return"Sponsor Bank Code - VALID"
    else:
        return"Sponsor Bank Code - INVALID  (BECAUSE FIELD IS NOT EMPTY)"

def vali_uc(gpt_json):
    if gpt_json["Utility Code"]=="NOT FOUND":
        return"Utility Code - VALID"
    else:
        return"Utility Code - INVALID  (BECAUSE FIELD IS NOT EMPTY)"
    
def vali_pan(gpt_json,result_az):
    pattern = r'[A-Z]{3}[C,H,F,A,T,B,L,J,G,P]{1}[A-Z]{1}[0-9]{4}[A-Z]{1}'
    matches = re.findall(pattern, gpt_json["PAN"])
    # print(matches)
    if not matches or  gpt_json["PAN"]=="NOT FOUND":
        matches1 = re.findall(pattern, result_az.replace(" ",""))
        # print(matches1)
        if not matches1:
            return "PAN - INVALID"
        else:

            gpt_json["PAN"]=matches1[0]
            return"PAN - VALID"
    else:
        if len(gpt_json["PAN"]) == 10:
            return "PAN - VALID"
        else:
            return "PAN - INVALID"

def vali_app_date(gpt_json):
    if gpt_json["Application Date"] == "NOT FOUND":
        return "Submission - INVALID"
    today_date = datetime.datetime.today()
    # print(today_date.strftime('%Y-%m-%d'))
    application_date = datetime.datetime.strptime(gpt_json["Application Date"], "%Y-%m-%d")
    # print(application_date)
    diff_days = (today_date - application_date).days
    # print(diff_days)
    if(diff_days>100):
        return "Submission - INVALID (IT HAS BEEN MORE THAN 100 DAYS)"
    else:
        return "Submission - VALID"

def vali_op_tick(gpt_json):
    if gpt_json["Operation"].upper() == "CREATE":
        return "Operation - VALID"
    else:
        return "Operation - INVALID (OTHER OPERATION SELECTED)"

def vali_auth(gpt_json):
    if gpt_json["Authorisation"].upper().replace("-"," ").replace("."," ").replace("  "," ") == "ICICI PRUDENTIAL ASSET MANAGEMENT COMPANY LIMITED":
        return "Authorisation - VALID"
    else:
        return "Authorisation - INVALID (INVALID BANK NAME FOUND)"

def vali_bacn(gpt_json):
    if gpt_json["Bank Account Number"].isnumeric()  and len(gpt_json["Bank Account Number"])>=9:
        return "Bank Account No - VALID "
    else:
        return "Bank Account No - INVALID (ACCOUNT NUMBER FORMAT IS WRONG)"

def vali_ifsc_format(ifsc):
    if ifsc.upper() == "NOT FOUND" or  ifsc[0:4] not in ifsc_db:
        return False

    test=ifsc
    prefix = test[0:4]
    b_code = test[5:]

    
    cont= ifsc_db[prefix]
    if not b_code.isnumeric():
        return False
    
    if int(b_code) in cont:
        return True
    
    return False

def vali_micr(gpt_json):
    if gpt_json["MICR"] == "NOT FOUND":
        return "MICR "+ gpt_json["MICR"]+" INVALID" 
    
    if gpt_json["MICR"] != "NOT FOUND":
        if(len(gpt_json["MICR"])==9) and gpt_json["MICR"].isnumeric():
            return "MICR "+ gpt_json["MICR"] + " VALID"
        else:
            return "MICR "+ gpt_json["MICR"] + " INVALID (MICR SHOULD BE OF 9 CHARACTERS)"
        
def vali_ifsc_micr(gpt_json):
    if gpt_json["IFSC"] == "NOT FOUND" and gpt_json["MICR"] == "NOT FOUND":
        return "IFSC OR MICR IS MANDATORY"
    else:
        if gpt_json["IFSC"] != "NOT FOUND" and gpt_json["MICR"] != "NOT FOUND":
            if vali_ifsc_format(gpt_json["IFSC"]):
                print("!!")
                return "IFSC "+ gpt_json["IFSC"] +" VALID" + "\n" + vali_micr(gpt_json)
            else:
                return "IFSC "+ gpt_json["IFSC"] +" INVALID (INCORRECT IFSC)" + "\n" + vali_micr(gpt_json)
        else:
            if gpt_json["IFSC"] != "NOT FOUND":
                if vali_ifsc_format(gpt_json["IFSC"]):
                    return "IFSC "+ gpt_json["IFSC"] + " VALID\n" + vali_micr(gpt_json)
                else:
                    return "IFSC "+ gpt_json["IFSC"] +" INVALID (INCORRECT IFSC)" + "\n" + vali_micr(gpt_json)
                
            if gpt_json["MICR"] != "NOT FOUND":
                    return "IFSC "+ gpt_json["IFSC"] +" INVALID " + "\n" + vali_micr(gpt_json)

def vali_bat(gpt_json):
    if gpt_json["Bank Account Type"] == "SB" or  gpt_json["Bank Account Type"] == "CC" or  gpt_json["Bank Account Type"] == "CA" or  gpt_json["Bank Account Type"] == "SB-NRE" or gpt_json["Bank Account Type"] == "SB-NRO" or gpt_json["Bank Account Type"] == "OTHER":
        return "Bank Account Type - VALID"
    else:
        return "Bank Account Type - INVALID (NONE OR MULTIPLE OPTIONS SELECTED)"    

def vali_bnk_name(gpt_json):
    if gpt_json["Bank Name"].upper() == "NOT FOUND":
        return "Bank Name - Invalid"
    
    if gpt_json["Bank Name"].upper() in   (x.upper() for  x in list(bank_nm_db.values())) :
        return "Bank Name - Valid"
    
    if  gpt_json["IFSC"][0:4] not in bank_nm_db:
        return "Bank Name - Invalid"
    else:
        temp_list= gpt_json["Bank Name"].upper().split(" ")
        actual_list= bank_nm_db[ gpt_json["IFSC"][0:4] ].upper().split(" ")
        # print(temp_list, actual_list)
        check= all(item in actual_list for item in  temp_list)
        if(check):
            return "Bank Name - Valid"
        else:
            return "Bank Name - Invalid"

def vali_from_dt(gpt_json):
    if(gpt_json["From Date"]!="NOT FOUND" and gpt_json["Application Date"]!="NOT FOUND"):
        today_date = datetime.datetime.today()
        application_date = datetime.datetime.strptime(gpt_json["Application Date"], "%Y-%m-%d")
        from_date = datetime.datetime.strptime(gpt_json["From Date"], "%Y-%m-%d")
        diff_days = (from_date - application_date).days
        if(diff_days>21):
            return "SIP FROM AND APPLICATION DATE GREATER THAN 21 DAYS"
        else:

            return "SIP FROM AND APPLICATION DATE VALID"
    else:
        return "SUBMISSION DATE AND SIP DATE VALIDATION CANNOT BE DONE"
    
def vali_folio(gpt_json1, gpt_json2):
    if gpt_json1["Mandate Type"] == "PAN BASED MANDATE":
        return "Folio - (NOT MANDATORY IN PAN BASED MANDATE)"
    else:
        if gpt_json1["Mandate Type"] == "FOLIO BASED MANDATE":
            if gpt_json2["Folio No"] == "NOT FOUND":
                return "Folio - (MANDATORY IN FOLIO BASED MANDATE)"
            else:
                return "Folio - VALID"
        else:
            return "Folio - (MANDATE TYPE NOT FOUND)"

def vali_sip_amount_comp(gpt_json1,gpt_json2):
    if gpt_json1["Amount"] != "NOT FOUND" and  gpt_json2["SIP Amount"] != "NOT FOUND" and gpt_json1["Amount"].isnumeric() and gpt_json2["SIP Amount"].isnumeric() :
        if gpt_json1["Amount"] >=  gpt_json2["SIP Amount"]:
            return "SIP AMOUNT - VALID"
        else:
            return "SIP AMOUNT - NACH AMT AND SIP AMT VALIDATION FAILED BECAUSE AMT NOT VALID"
    else:
        return "SIP AMOUNT - NACH AMT AND SIP AMT VALIDATION FAILED BECAUSE AMT NOT VALID"

def vali_sip_amt(gpt_json1,tk):
    gpt_json1[tk]  = gpt_json1[tk]
    if gpt_json1[tk]  != "NOT FOUND": 
        getVals = list([val for val in gpt_json1[tk] if val.isnumeric()])
        gpt_json1[tk]  = "".join(getVals)
        if gpt_json1[tk] == "":
            gpt_json1[tk]="NOT FOUND"
            pass
        else:    
            return "SIP AMOUNT - VALID"
    else:
        return "SIP AMOUNT - INVALID"

def vali_not_found_ck(gpt_json1,tk):
    if gpt_json1[tk]  != "NOT FOUND": 
        return f"{tk} - VALID"
    else:
        return f"{tk} - INVALID"

def vali_phone_num(gpt_json):
    if gpt_json["mobile_no"]!= "NOT FOUND":
        print( gpt_json["mobile_no"].isnumeric() )
        if gpt_json["mobile_no"].isnumeric() and len(gpt_json["mobile_no"])==10:
             return "MOBILE NO - VALID"
        else:
            return "MOBILE NO - FORMAT INVALID" 
    else:
        return "MOBILE NO - INVALID" 



def comp_validation_1(gpt_json,result_az):
    gpt_json["IFSC"]= gpt_json["IFSC"].replace(".","")
    gpt_json["PAN"]= gpt_json["PAN"].replace(".","")
    ans=[]

    ans.append("Mandate Type - " +gpt_json["Mandate Type"])
    ans.append(vali_umrn(gpt_json))
    ans.append(vali_app_date(gpt_json) )
    ans.append(vali_sbc(gpt_json))
    ans.append(vali_uc(gpt_json))
    ans.append(vali_op_tick(gpt_json))
    ans.append(vali_auth(gpt_json))
    ans.append(vali_bat(gpt_json))
    ans.append(vali_bacn(gpt_json))
    ans.append(vali_not_found_ck(gpt_json,"Bank Name"))
    ans.append(vali_ifsc_micr(gpt_json))
    ans.append(vali_pan(gpt_json,result_az))
    
    ans.append(vali_not_found_ck(gpt_json,"Name"))
    ans.append(vali_sip_amt(gpt_json,"Amount"))
    ans.append(vali_not_found_ck(gpt_json,"Amount of rupees(in words)") )
    ans.append(vali_not_found_ck(gpt_json,"From Date"))
    ans.append(vali_not_found_ck(gpt_json,"To Date"))
    ans.append(vali_not_found_ck(gpt_json,"Application Number") )
    ans.append(vali_not_found_ck(gpt_json,"email_id"))
    ans.append(vali_phone_num(gpt_json))
    ans.append(vali_from_dt(gpt_json))

    return ans

def comp_validation_2(gpt_json2):
    ans=[]

    ans.append(vali_sip_amt(gpt_json2,"SIP Amount"))
    ans.append(vali_not_found_ck(gpt_json2,"Scheme_name"))
    ans.append(vali_not_found_ck(gpt_json2,"From Date"))
    ans.append(vali_not_found_ck(gpt_json2,"To Date"))
    ans.append(vali_not_found_ck(gpt_json2,"Cycle Date"))
    ans.append(vali_not_found_ck(gpt_json2,"Applicant Name"))
    # ans.append( "Investor Name "+" - "+ gpt_json2["Scheme_name"])
    # ans.append( "Frequency "+" - "+ gpt_json2["Frequency"])
    # ans.append( "Registration via otm "+" - "+ str(gpt_json2["Registration via otm"]))
    # ans.append( vali_folio(gpt_json1,gpt_json2))
    # ans.append( vali_sip_amount_comp(gpt_json1,gpt_json2) )

    return ans

def comp_validation_3(gpt_json1,gpt_json2):
    ans=[]
    ans.append( vali_folio(gpt_json1,gpt_json2))
    ans.append( vali_sip_amount_comp(gpt_json1,gpt_json2) )
    return ans

def entry_point(f_nm_temp):
    zzz=[]
    f_nm= f_nm_temp
    img= Image.open(f"static/uploads/{f_nm}").convert('RGB')
    h=img.height
    w= img.width
    # print(h/2,w)
    img = img.crop((0, 0, w,(h/2)))
    img.save("temp_img_store/crop_img1.jpg","JPEG")


    img= Image.open(f"static/uploads/{f_nm}").convert('RGB')
    img = img.crop((0, (h/2) ,w,h))
    img.save("temp_img_store/crop_img2.jpg","JPEG")

    result_az= get_ans("temp_img_store/crop_img1.jpg")
    result_gpt= gpt_format(result_az,prompt1)

    result_az2= get_ans("temp_img_store/crop_img2.jpg")
    result_gpt2= gpt_format(result_az2,prompt2)


    f_ans = comp_validation_1(result_gpt,result_az)
    zzz=[]
    for temp in f_ans:
        # print(temp)
        zzz.append(str(temp))

    zzz.append("")
    
    f_ans2 = comp_validation_2(result_gpt2)
    for temp in f_ans2:
        # print(temp)
        zzz.append(str(temp))

    print(result_gpt)
    print("----x---")
    print(result_gpt2)
    # fun2(zzz)
    print(str(zzz))
    return zzz



def entry_point2(f_nm_temp):
    zzz=[]

    thread_one = threading.Thread(target=fun1(zzz))
    thread_two = threading.Thread(target=fun2(zzz))

    f_nm= f_nm_temp
    img= Image.open(f"static/uploads/{f_nm}").convert('RGB')
    h=img.height
    w= img.width
    # print(h/2,w)
    img = img.crop((0, 0, w,(h/2)))
    img.save("temp_img_store/crop_img1.jpg","JPEG")


    img= Image.open(f"static/uploads/{f_nm}").convert('RGB')
    img = img.crop((0, (h/2) ,w,h))
    img.save("temp_img_store/crop_img2.jpg","JPEG")
        
    thread_one.start()
    thread_two.start()
    
    thread_two.join()
    thread_one.join()
    # fun2(zzz)
    print(str(zzz))
    # return zzz

def fun1(zzz):
    print("in func1")
    result_az= get_ans("temp_img_store/crop_img1.jpg")
    print("func1 az done")
    result_gpt= gpt_format(result_az,prompt1)
    print("func1 gpt done")

    f_ans = comp_validation_1(result_gpt,result_az)
    fun_1_list=[]
    for temp in f_ans:
        print(temp)
        zzz.append(str(temp))
        fun_1_list.append(str(temp))
    
    # return fun_1_list

def fun2(zzz):
    print("in func2")
    result_az2= get_ans("temp_img_store/crop_img2.jpg")
    print(" func2 az done")
    result_gpt2= gpt_format(result_az2,prompt2)
    print("func2 gpt done")
    fun_2_list=[]
    f_ans2 = comp_validation_2(result_gpt2)
    for temp in f_ans2:
        print(str(temp))
        zzz.append(str(temp))
        # fun_2_list.append(str(temp))


    # return fun_2_list



entry_point("form2_test.JPG")
